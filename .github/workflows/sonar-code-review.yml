name: Sonar + Gemini Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
    branches: [ main ]

jobs:
  sonar:
    name: SonarQube Scan (action) + Quality Gate check
    runs-on: ubuntu-latest
    environment: stt-environment
    env:
      SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt || true

      - name: Validate Sonar secrets (fail early)
        run: |
          if [ -z "${SONAR_HOST_URL}" ] || [ -z "${SONAR_TOKEN}" ] || [ -z "${SONAR_PROJECT_KEY}" ]; then
            echo "ERROR: SONAR_HOST_URL, SONAR_TOKEN, SONAR_PROJECT_KEY must be set as secrets/vars."
            exit 1
          fi
          if [[ ! "${SONAR_HOST_URL}" =~ ^https?:// ]]; then
            echo "ERROR: SONAR_HOST_URL must include http:// or https://"
            exit 1
          fi
          echo "Sonar config looks good."

      - name: Run tests and generate coverage
        run: |
          pip install pytest pytest-cov
          pytest --cov=. --cov-report=xml:coverage.xml

      - name: Run SonarQube Scan (official action)
        uses: sonarsource/sonarqube-scan-action@v3
        env:
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.projectKey=${{ env.SONAR_PROJECT_KEY }}
            -Dsonar.projectName="stt"
            -Dsonar.sources=.
            -Dsonar.python.version=3.10
            -Dsonar.qualitygate.wait=false
            -Dsonar.verbose=true
            -Dsonar.python.coverage.reportPaths=coverage.xml
        
      - name: Copy scanner output for later steps
        run: |
          echo "Copying scanner output..."
          if [ -d .scannerwork ]; then
            cp -r .scannerwork $GITHUB_WORKSPACE/.scannerwork || true
          elif [ -d .sonar ]; then
            cp -r .sonar $GITHUB_WORKSPACE/.scannerwork || true
          else
            echo "No scanner output directory found."
          fi

      - name: Sonar debug -- show report-task.txt & query server issues
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
        run: |
          set -e
          echo "Workspace files (top-level):"
          ls -la || true
          REPORT_PATH=$(find . -type f -name 'report-task.txt' | head -n 1 || true)
          if [ -n "$REPORT_PATH" ]; then
            echo "---- $REPORT_PATH ----"
            cat "$REPORT_PATH"
            echo "--------------------------------------"
          else
            echo "report-task.txt not found in workspace."
          fi
          echo "Querying Sonar for recent issues (first 50)..."
          BASE="${SONAR_HOST_URL%/}"
          curl -s -u "${SONAR_TOKEN}:" "${BASE}/api/issues/search?componentKeys=${SONAR_PROJECT_KEY}&ps=50" \
            | jq '.paging, .issues | {count: (. | length), issues: .[0:10]}' || true
          echo "Querying quality gate (project_status)..."
          curl -s -u "${SONAR_TOKEN}:" "${BASE}/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" | jq . || true

      - name: Ensure jq is available (for polling JSON)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Wait for Sonar analysis & check Quality Gate
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
        run: |
          set -euo pipefail
          echo "ðŸ”Ž Searching for report-task.txt..."

          # 1ï¸âƒ£ Locate report-task.txt dynamically
          REPORT_PATH=$(find . -type f -name 'report-task.txt' | head -n 1 || true)
          if [ -z "$REPORT_PATH" ]; then
            echo "âŒ report-task.txt not found in workspace. Sonar scanner might have failed or been skipped."
            echo "Listing workspace for debugging:"
            ls -R | head -n 100
            exit 1
          fi

          echo "âœ… Found report-task.txt at: $REPORT_PATH"
          cat "$REPORT_PATH"

          # 2ï¸âƒ£ Extract Compute Engine URL and analysis ID
          CE_URL=$(grep '^ceTaskUrl=' "$REPORT_PATH" | cut -d'=' -f2- || true)
          ANALYSIS_ID=$(grep '^analysisId=' "$REPORT_PATH" | cut -d'=' -f2- || true)
          if [ -z "$CE_URL" ]; then
            echo "âš ï¸ No ceTaskUrl found in report-task.txt; will poll project status directly."
          fi

          sonar_api() {
            local path="$1"
            curl -s -u "${SONAR_TOKEN}:" "${SONAR_HOST_URL%/}${path}"
          }

          # 3ï¸âƒ£ Poll SonarQube Compute Engine if CE_URL available
          if [ -n "$CE_URL" ]; then
            echo "â³ Polling SonarQube Compute Engine task..."
            for i in $(seq 1 60); do
              TASK_JSON=$(curl -s -u "${SONAR_TOKEN}:" "$CE_URL")
              STATUS=$(echo "$TASK_JSON" | jq -r '.task.status // empty')
              echo "  Attempt $i - task.status=$STATUS"
              if [ "$STATUS" = "SUCCESS" ]; then
                ANALYSIS_ID=$(echo "$TASK_JSON" | jq -r '.task.analysisId // empty')
                echo "âœ… Compute Engine task finished successfully."
                break
              fi
              if [ "$STATUS" = "FAILED" ]; then
                echo "âŒ Sonar Compute Engine task failed:"
                echo "$TASK_JSON" | jq .
                exit 1
              fi
              sleep 5
            done
          fi

          # 4ï¸âƒ£ If still no ANALYSIS_ID, fallback to polling projectKey
          if [ -z "$ANALYSIS_ID" ]; then
            echo "âš ï¸ analysisId not found. Polling project status as fallback..."
            for i in $(seq 1 60); do
              QG_JSON=$(sonar_api "/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}")
              STATUS=$(echo "$QG_JSON" | jq -r '.projectStatus.status // empty')
              echo "  attempt $i - projectStatus.status=${STATUS:-none}"
              if [ -n "$STATUS" ] && [ "$STATUS" != "PENDING" ]; then
                ANALYSIS_ID=$(echo "$QG_JSON" | jq -r '.projectStatus.analysisId // empty')
                break
              fi
              sleep 5
            done
          fi

          # 5ï¸âƒ£ If still unknown, fallback to latest project status
          if [ -z "$ANALYSIS_ID" ]; then
            echo "âš ï¸ Could not determine analysisId. Using latest quality gate status as final fallback..."
            QG_JSON=$(sonar_api "/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}")
            STATUS=$(echo "$QG_JSON" | jq -r '.projectStatus.status // "UNKNOWN"')
            echo "$QG_JSON" | jq .
            echo "Quality Gate status (fallback): $STATUS"
            if [ "$STATUS" = "OK" ]; then
              echo "âœ… Quality Gate passed (fallback)."
              exit 0
            else
              echo "âŒ Quality Gate failed or unknown (fallback)."
              exit 1
            fi
          fi

          # 6ï¸âƒ£ Query final Quality Gate status by analysisId
          echo "Using analysisId: ${ANALYSIS_ID}"
          QG_JSON=$(sonar_api "/api/qualitygates/project_status?analysisId=${ANALYSIS_ID}")
          echo "$QG_JSON" | jq .

          QG_STATUS=$(echo "$QG_JSON" | jq -r '.projectStatus.status // "UNKNOWN"')
          echo "Final Quality Gate status: ${QG_STATUS}"

          if [ "$QG_STATUS" = "OK" ]; then
            echo "âœ… Quality Gate passed."
            exit 0
          else
            echo "âŒ Quality Gate failed (status=${QG_STATUS}). See Sonar dashboard for details."
            echo "Failed conditions:"
            echo "$QG_JSON" | jq -r '.projectStatus.conditions[] | " - " + (.metricKey // "unknown") + ": " + (.status // "UNKNOWN") + (if .actualValue then " (" + (.actualValue|tostring) + ")" else "" end)' || true
            exit 1
          fi

  gemini-review:
    name: Gemini AI Code Review
    needs: sonar
    # run only when sonar job succeeded
    if: ${{ needs.sonar.result == 'success' }}
    runs-on: ubuntu-latest
    environment: stt-environment
    env:
      SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure PR context exists
        id: pr_check
        run: |
          if [ -z "${{ github.event.pull_request.number }}" ]; then
            echo "No pull_request context found; exiting."
            echo "has_pr=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          echo "has_pr=true" >> $GITHUB_OUTPUT

      - name: Get Pull Request Diff
        if: ${{ steps.pr_check.outputs.has_pr == 'true' }}
        id: get_diff
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUM=${{ github.event.pull_request.number }}
          echo "Fetching PR diff for PR #${PR_NUM}"
          gh api repos/${{ github.repository }}/pulls/${PR_NUM} \
            --header "Accept: application/vnd.github.v3.diff" > pr_diff.txt
          echo "Saved pr_diff.txt (size: $(wc -c < pr_diff.txt) bytes)"

      - name: Fetch SonarQube PR analysis (if configured)
        if: ${{ env.SONAR_HOST_URL && env.SONAR_TOKEN && env.SONAR_PROJECT_KEY && steps.pr_check.outputs.has_pr == 'true' }}
        env:
          BASE: ${{ env.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ env.SONAR_PROJECT_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -e
          BASE="${BASE%/}"
          echo "Fetching Sonar data for project=${SONAR_PROJECT_KEY}, PR=${PR_NUMBER}"

          # Issues for this PR
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/issues/search?componentKeys=${SONAR_PROJECT_KEY}&pullRequest=${PR_NUMBER}&ps=500" \
            -o sonar_issues.json || echo "{}" > sonar_issues.json

          # Quality gate status
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" \
            -o sonar_qg.json || echo "{}" > sonar_qg.json

          # Key measures
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/measures/component?component=${SONAR_PROJECT_KEY}&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density" \
            -o sonar_measures.json || echo "{}" > sonar_measures.json

          # Build human-readable summary
          echo "### SonarQube Analysis Summary for PR #${PR_NUMBER}" > sonar_summary.txt
          echo "" >> sonar_summary.txt

          echo "Quality Gate:" >> sonar_summary.txt
          if jq -e '.projectStatus' sonar_qg.json >/dev/null 2>&1; then
            jq -r '.projectStatus | "  status: " + (.status // "UNKNOWN")' sonar_qg.json >> sonar_summary.txt
          else
            echo "  Unable to fetch quality gate" >> sonar_summary.txt
          fi
          echo "" >> sonar_summary.txt

          echo "Key metrics:" >> sonar_summary.txt
          if jq -e '.component.measures' sonar_measures.json >/dev/null 2>&1; then
            jq -r '.component.measures[] | "  - " + .metric + ": " + (.value // "null")' sonar_measures.json >> sonar_summary.txt
          else
            echo "  Unable to fetch measures" >> sonar_summary.txt
          fi
          echo "" >> sonar_summary.txt

          echo "Top Sonar issues (up to 20):" >> sonar_summary.txt
          if jq -e '.issues' sonar_issues.json >/dev/null 2>&1; then
            jq -r '.issues | sort_by(.severity) | reverse | .[] | ("  - [" + (.severity // "INFO") + "] " + (.rule // "unknown") + " / " + (.component // "unknown") + (if .line then ":" + (.line|tostring) else "" end) + " â€” " + (.message|gsub("\n"; " ")))' sonar_issues.json | sed -n '1,20p' >> sonar_summary.txt
          else
            echo "  No issues found or failed to parse" >> sonar_summary.txt
          fi
          echo "" >> sonar_summary.txt

          echo "Issue counts by severity:" >> sonar_summary.txt
          if jq -e '.issues' sonar_issues.json >/dev/null 2>&1; then
            jq -r '.issues | group_by(.severity) | map({(.[0].severity): length}) | add | to_entries[] | "  - " + .key + ": " + (.value|tostring)' sonar_issues.json >> sonar_summary.txt 2>/dev/null || echo "  none" >> sonar_summary.txt
          else
            echo "  none" >> sonar_summary.txt
          fi

          ls -l sonar_*.json sonar_summary.txt || true
          echo "âœ… Sonar summary prepared."

      - name: Combine Prompt, Sonar summary and Diff
        run: |
          # Build the prompt file
          cat .gemini/prompt.txt > full_prompt.txt || echo "Base prompt not found" > full_prompt.txt
          echo -e "\n\n## ðŸ”Ž SonarQube Summary\n\n" >> full_prompt.txt
          if [ -f sonar_summary.txt ]; then
            cat sonar_summary.txt >> full_prompt.txt
          else
            echo "No Sonar summary available." >> full_prompt.txt
          fi
          echo -e "\n\n## ðŸ”„ Full Diff Below\n\n" >> full_prompt.txt
          if [ -f pr_diff.txt ]; then
            cat pr_diff.txt >> full_prompt.txt
          else
            echo "No PR diff available." >> full_prompt.txt
          fi
          echo "âœ… Full prompt ready at full_prompt.txt"

      - name: Load Prompt from File
        id: load_prompt
        run: |
          PROMPT_CONTENT=$(cat full_prompt.txt || echo "No prompt file")
          echo "prompt_text<<EOF" >> $GITHUB_OUTPUT
          echo "$PROMPT_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run Gemini Code Review
        id: run_gemini
        uses: google-github-actions/run-gemini-cli@v0.1.14
        with:
          gemini_model: "gemini-2.5-pro"
          gemini_api_key: ${{ env.GEMINI_API_KEY }}
          use_vertex_ai: false
          use_gemini_code_assist: false
          prompt: ${{ steps.load_prompt.outputs.prompt_text }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Save Gemini Output (robust)
        id: save_gemini
        run: |
          echo "ðŸ“„ Saving Gemini output..."
          candidates=(
            "gemini-artifacts/stdout.log"
            "stdout.log"
            "gemini-artifacts/stdout.txt"
            "gemini-output.txt"
          )
          found=""
          for f in "${candidates[@]}"; do
            if [ -f "$f" ]; then
              found="$f"
              break
            fi
          done
          if [ -z "$found" ]; then
            found=$(find . -type f -name 'stdout.log' -print -quit || true)
          fi
          if [ -n "$found" ]; then
            echo "Found Gemini output at: $found"
            tail -n 2000 "$found" > gemini_output.txt || cp "$found" gemini_output.txt
          else
            echo "No Gemini output found. Writing fallback message."
            echo "Gemini action produced no output file. Check run_gemini logs." > gemini_output.txt
          fi
          echo "=== gemini_output.txt preview ==="
          sed -n '1,200p' gemini_output.txt || true

      - name: Post Gemini Review as PR Comment
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let output = "No Gemini review output generated.";
            try {
              if (fs.existsSync('gemini_output.txt')) {
                output = fs.readFileSync('gemini_output.txt', 'utf8').trim();
                if (!output) {
                  output = "Gemini ran but produced empty output.";
                }
              }
            } catch (err) {
              output = "Failed to read gemini_output.txt: " + err.toString();
            }
            const maxLen = 60000;
            if (output.length > maxLen) {
              output = output.slice(0, maxLen) + "\n\n(Truncated output...)";
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `### ðŸ¤– Gemini Code Review Result\n\n${output}`
            });